#!/usr/bin/env ruby
# frozen_string_literal: true

# Langop Agent Entrypoint
#
# This script auto-loads synthesized agent code from a ConfigMap volume
# or falls back to default agent behavior if no code is provided.
#
# The operator synthesizes agent DSL code from natural language instructions
# and mounts it as a ConfigMap at AGENT_CODE_PATH.

# Disable output buffering for immediate log visibility
$stdout.sync = true
$stderr.sync = true

require 'language_operator'

# Wait for tool sidecars to be ready
def wait_for_tools(config)
  return unless config['mcp_servers']

  require 'net/http'
  require 'uri'

  servers = config['mcp_servers'] || []
  servers.each do |server|
    url = server['url']
    next unless url&.start_with?('http')

    uri = URI.parse(url)
    max_attempts = 30
    delay = 1

    puts "â³ Waiting for tool at #{uri.host}:#{uri.port}..."

    max_attempts.times do |attempt|
      begin
        # Try to connect to the health endpoint or root
        response = Net::HTTP.start(uri.host, uri.port, open_timeout: 1, read_timeout: 1) do |http|
          http.head('/')
        end
        puts "âœ… Tool ready at #{uri.host}:#{uri.port}"
        break
      rescue StandardError => e
        if attempt < max_attempts - 1
          sleep(delay)
        else
          puts "âš ï¸  Tool at #{uri.host}:#{uri.port} not ready after #{max_attempts} attempts"
        end
      end
    end
  end
end

# Configuration
code_path = ENV.fetch('AGENT_CODE_PATH', '/etc/agent/code/agent.rb')
fallback_mode = ENV.fetch('AGENT_FALLBACK_MODE', 'error') # error | autonomous | interactive

puts "ğŸ¤– Langop Agent starting..."
puts "ğŸ“ Code path: #{code_path}"

# Check if synthesized code exists
if File.exist?(code_path)
  puts "âœ… Found synthesized agent code, loading..."

  begin
    # Load the synthesized DSL code using the agent loader
    # This provides the DSL context with the 'agent' method
    LanguageOperator::Dsl.load_agent_file(code_path)

    # The synthesized code should define an agent
    puts "âœ… Agent code loaded successfully"

    # Get the agent from the registry
    agents = LanguageOperator::Dsl.agent_registry.all
    if agents.empty?
      puts "âŒ No agent defined in code"
      exit 1
    end

    agent_def = agents.first
    puts "ğŸš€ Running agent: #{agent_def.name}"

    # Execute the agent based on its definition
    # For now, create a basic executor with the environment config
    # TODO: Implement proper agent execution based on AgentDefinition workflows
    config = LanguageOperator::Client::Config.from_env
    agent = LanguageOperator::Agent::Base.new(config)

    # Wait for tool sidecars to be ready before connecting
    # This prevents connection failures during pod startup
    wait_for_tools(config)

    agent.connect!

    # Get instructions from agent definition or environment
    instructions = agent_def.description || ENV['AGENT_INSTRUCTIONS']
    if instructions && !instructions.empty?
      puts "ğŸ“‹ Instructions: #{instructions[0..200]}..."
      executor = LanguageOperator::Agent::Executor.new(agent)
      executor.execute(instructions, agent_definition: agent_def)
    else
      puts "âŒ No instructions provided"
      exit 1
    end

  rescue StandardError => e
    puts "âŒ Error loading agent code: #{e.message}"
    puts e.backtrace.take(5).join("\n")

    case fallback_mode
    when 'autonomous'
      puts "âš ï¸  Falling back to autonomous mode with default config"
      fallback_to_autonomous
    when 'interactive'
      puts "âš ï¸  Falling back to interactive mode"
      fallback_to_interactive
    else
      puts "âŒ No fallback configured, exiting"
      exit 1
    end
  end

else
  puts "âš ï¸  No synthesized code found at #{code_path}"

  case fallback_mode
  when 'autonomous'
    puts "ğŸ“ Starting in autonomous mode with default config"
    fallback_to_autonomous
  when 'interactive'
    puts "ğŸ“ Starting in interactive mode"
    fallback_to_interactive
  else
    puts "âŒ No agent code provided and no fallback configured"
    puts "ğŸ’¡ The operator should have created a ConfigMap with synthesized code"
    puts "ğŸ’¡ Check LanguageAgent status for synthesis errors"
    exit 1
  end
end

# Fallback implementations
def fallback_to_autonomous
  config = LanguageOperator::Client::Config.load_with_fallback
  agent = LanguageOperator::Agent::Base.new(config)

  # Get instructions from environment
  instructions = ENV['AGENT_INSTRUCTIONS']

  if instructions && !instructions.empty?
    puts "ğŸ“‹ Instructions: #{instructions[0..200]}..."
    agent.connect!

    # Simple autonomous loop
    executor = LanguageOperator::Agent::Executor.new(agent)
    executor.execute(instructions)
  else
    puts "âŒ No instructions provided in AGENT_INSTRUCTIONS"
    exit 1
  end
end

def fallback_to_interactive
  puts "Interactive mode not yet implemented"
  exit 1
end
